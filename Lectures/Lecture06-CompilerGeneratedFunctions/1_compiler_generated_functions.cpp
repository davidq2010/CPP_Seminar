////////////////////////////////////////////////////////////////////////////////
/// @file
/// @brief Brief overview of special member functions, explicit, and noexcept.
///
/// Outline
///  - Special member functions
///    - Rules of compiler generated versions.
///  - Explicit
///  - noexcept
////////////////////////////////////////////////////////////////////////////////

#include <iostream>
#include <string>
using namespace std;

////////////////////////////////////////////////////////////////////////////////
/// Special member functions
///
/// - Special member functions are those functions which can be invoked by 
///   compiler generated pieces of code. For example, assume a variable goes out
///   of scope. In this case, the compiler inserts automatically an invocation
///   to the destructor. The following are special member functions:
///  - No-argument (default) constructor
///  - Destructor
///  - Copy construction
///  - Copy assignment
///  - Move construction
///  - Move assignment
/// - The compiler will write (generate) special member functions automatically
///   under the following rules:
///   1) A no-agument constructor (default) is provided when no user-defined 
///      constructors are provided. Generated as member-wise default 
///      initialization.
///   2) A destructor is provided when no-user defined constructors are provided.
///      Generated as member-wise destruction.
///   3) A copy constructor/assignment is provided when no user defined copy
///      constructor/assignment is provided. Copy is performed member-wise. Copy
///      constructor/assignment is deleted if a user defined move 
///      constructor/assign is present.
///   4) Move constructor/assignment is provided if the class does not contain
///      a user defined move constructor/assignment, copy constructor/assignment
///      or destructor. This method will perform a member-wise move.
/// - The implementation of user-defined special member function can be 
///   specified to be generated by the compiler with "= default".
/// - A special member function can be explicitely excluded from a class with
///   "= delete".
/// - Best practices
///   - Decide by design what you want, i.e., allow no-arg construct, copying,
///     moving, etc. 
///   - Explicitely declare all as =default or =delete (or specialize of 
///     course).
/// - Example classes of compiler generated functions below.
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////
/// @brief Example class with commented
///        sections of compiler 
///        generated code.
///////////////////////////////////////
class Foo {
  private:
    int m_i;
    string m_s;

  public:
    Foo() = default; // User defined as the compiler generated version.
    Foo(int _i, const string& _s) : m_i{_i}, m_s{_s} {}

    // Compiler generates:
    // ~Foo()
    // Foo(const Foo&)
    // Foo& operator=(const Foo&)
    // Foo(Foo&&)
    // Foo& operator=(Foo&&)

    void print() {
      cout << "I: " << m_i << "\tS: " << m_s << endl;
    }
};

///////////////////////////////////////
/// @brief Example class with commented
///        sections of compiler 
///        generated code.
///////////////////////////////////////
class Bar {
  private:
    int m_i;
    string m_s;

  public:
    Bar() = default; // User defined as the compiler generated version.
    Bar(int _i, const string& _s) : m_i{_i}, m_s{_s} {}

    // Explicitely delete copying
    Bar(const Bar&) = delete;
    Bar& operator=(const Bar&) = delete;

    // Explicitely add moving, as user-defined copy prevents a move from being
    // generated.
    Bar(Bar&&) = default;
    Bar& operator=(Bar&&) = default;

    // Compiler generates:
    // ~Bar()

    void print() {
      cout << "I: " << m_i << "\tS: " << m_s << endl;
    }
};

///////////////////////////////////////
/// @brief Main tester
/// @returns Success/failure.
int 
main() {
  Foo f; // Compiler invokes the no-arg constructor, even though you didn't 
         // write it.
  Foo f2{5, "Hi"};

  f.print();
  f2.print();

  Foo f3 = f; // Copy construction for free, even though it isn't specified.
  Foo f4 = move(f2); // Move construction for free, even though it isn't 
                     // written.

  f3.print();
  f4.print();
  
  Bar b{4, "There"};
  b.print();

  //Bar b2 = b; // Compiler error, no copy!
  Bar b3 = move(b); // Works!

  b3.print();

  // Compiler adds the following calls to special member functions 
  // automatically.
  //~f();
  //~f2();
  //~f3();
  //~f4();
  //~b();
  //~b3();
}