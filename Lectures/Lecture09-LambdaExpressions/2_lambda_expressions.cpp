////////////////////////////////////////////////////////////////////////////////
/// Lambda Expressions
///
/// - Terms
///   - Lambda expression - a nameless function described by a special syntax.
///   - Closure class - a function object class generated by the compiler for a
///     lambda expression.
///   - Closure - a function object instance generated by the compiler for a
///     lambda expression.
/// - Syntax
///   [capture](parameter_list){function_body}
///   - Capture states variables to copy (or refer to) outside of lambda scope.
///   - Parameter list and function body is the same as any other function.
/// - C++ allows lambda expressions to capture local variables by reference or
///   by value.
///   - Default modes: no capture, by-reference, by-value
///   - Explicit capture lists variables to capture by reference.
///   - Avoid blanket default capture modes as they could be at risk for
///     dangling pointers (or understnad when this can occur).
///   - Recommend to use explicit capture instead.
///   - Further, recommend to use the C++14's generalized lambda capture and
///     generic lambda syntax (auto as parameters).
/// - Examples below.
////////////////////////////////////////////////////////////////////////////////

#include <array>
#include <algorithm>
#include <iostream>

///////////////////////////////////////
/// @brief Main driver
/// @return Success/fail
int
main() {
  std::array<int, 10> arr = {3, 4, 2, 5, 1, 6, 4, 3, 2, 7};
  // Basic lambda without capture.
  auto no_capture = [](const int& a, const int& b) {return a >= b;};
  std::sort(arr.begin(), arr.end(), no_capture);
  std::for_each(arr.begin(), arr.end(),
    [](const int& a){std::cout << a << " ";}
  );
  std::cout << std::endl;

  // Lambda with default by-reference capture
  int factor = 1;
  auto ref_capture = [&](int& a){a *= factor; factor += 1;}; // Note factor will change over time
  std::for_each(arr.begin(), arr.end(), ref_capture);
  std::for_each(arr.begin(), arr.end(),
    [](const int& a){std::cout << a << " ";}
  );
  std::cout << std::endl;

  // Lambda with default by-value capture
  int divisor = 3;
  auto val_capture = [=](int& a){a /= divisor; /*divisor+= 1;*/}; // Divisor is read only!
  std::for_each(arr.begin(), arr.end(), val_capture);
  std::for_each(arr.begin(), arr.end(),
    [](const int& a){std::cout << a << " ";}
  );
  std::cout << std::endl;

  // Lambda with explicit capture using generalized lambda capture
  // Also showing generic lambda use
  int eq = 5;
  auto val_capture2 = [eq = eq](auto& a) {return a == eq;};
  std::cout << "Count 5: "
    << std::count_if(arr.begin(), arr.end(), val_capture2)
    << std::endl;
}